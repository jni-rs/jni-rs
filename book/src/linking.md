# Linking

This section introduces the starter code that you downloaded in the
[introduction](./introduction.md), and the unique annotations and naming process
to write JNI functions.

# Whats in NativeAPI?

`NativeAPI` is a class that lives in Java side of `jni_rs_java`. It loads the
`jnibookrs` shared library via
[`System.loadLibrary`](https://docs.oracle.com/javase/9/docs/api/java/lang/System.html#loadLibrary-java.lang.String-),
and provides access to the native JNI functions. It contains the `verifyLink` to
test that the environment supports JNI, is configured properly, and to provide
an example of a native function.

```java
{{#include ../projects/starter/jnibookgradle/src/main/java/jni_rs_book/NativeAPI.java}}
```

When you need to introduce a new native method, consider adding it to
`NativeAPI`. 

## Function Linking Rules
Now, we'll start digging into the rules for writing JNI code with Rust. This
section introduces naming Rust JNI functions, so that they may be used from
Java, as well as JNI parameters and return types.

### Naming Rust Functions for JNI
JNI encodes the [package path, class name, function name, and more to uniquely
identify the function that Java will
use.](https://docs.oracle.com/en/java/javase/11/docs/specs/jni/design.html#resolving-native-method-names)
Fortunately, you don't have to learn the rules, since `javac` can be used to
generate a C header file, out of which you can copy for use within Rust. As an
example, we'll generate a function name for the `verify_link` native method in
`NativeAPI`.

Run `javac -h . NativeAPI.java` to produce C headers. You will see a file called
   `jni_rs_book_NativeAPI.h` that contains the following:

```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class jni_rs_book_NativeAPI */

#ifndef _Included_jni_rs_book_NativeAPI
#define _Included_jni_rs_book_NativeAPI
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     jni_rs_book_NativeAPI
 * Method:    verify_link
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_jni_1rs_1book_NativeAPI_verify_1link
  (JNIEnv *, jclass);

#ifdef __cplusplus
}
#endif
#endif
```

`Java_jni_1rs_1book_NativeAPI_verify_1link` corresponds to the native method in
`verify_link`. We don't need to do anything with it, since the function is
already implemented in `verifylink.rs`:


```rust,noplaypen
{{#include ../projects/completed/jnibookrs/src/verifylink.rs:complete_no_info}}
```

Aside from the name, there's a lot of extra stuff in this function. So, next
we're going to look at the other components. If these aspects don't interest you
too much, then just remember there are some steps that you need to follow for
JNI native methods.

### Disabling Mangling and Specifying the ABI
There are a few annotations that must be applied to Rust functions, so that they
work with JNI. First, `#[no_mangle]` must be added to opt-out of name mangling
(a compiler technique that the Rust compiler leverages by default), so that the
symbol name in the native artifact is the same as the function name. Secondly,
`extern "system"` must be used to specify the ABI (Application Binary Interface)
to one that Java expects. For further information, see
[extern](https://doc.rust-lang.org/std/keyword.extern.html) and
[abi](https://doc.rust-lang.org/beta/reference/items/external-blocks.html#abi).
Applying these two, we wind up with:

```rust,noplaypen
{{#include ../projects/completed/jnibookrs/src/verifylink.rs:imports}}

{{#include ../projects/completed/jnibookrs/src/verifylink.rs:link_0}}
```


### Parameters
The first argument to every JNI function is `JNIEnv`, which is an object you can
use to call into the JVM. The second argument is a reference to `this`, which is
a `JClass` for static methods and `JObject` for instance methods. The next
arguments map 1:1 with parameters specified in the Java method's signature. For
example, if the signature was `void add(int a, int b)`, then the 3rd and 4th
arguments in the native function would be of type `jni::sys::jint`.

Since `verify_link` is static and takes no additional arguments, the function
should be written as:

```rust,noplaypen
{{#include ../projects/completed/jnibookrs/src/verifylink.rs:imports}}

{{#include ../projects/completed/jnibookrs/src/verifylink.rs:complete}}
```
# Summary

It's OK if the JNI naming conventions and parameters look unfamiliar. There are
a lot of steps involved, compared to normal Rust code. The key takeaways are:

1. `javac` can be used to generate function names
2. JNI functions need to be annotated with `#[no_mangle]`, and defined with
   `extern "system"`
3. `JNIEnv` and `JClass` are the first two args for static native functions. For
   instance native functions, they are `JNIEnv` and `JObject`.
4.  `JNIEnv` is the sole entrypoint through which Java objects may be accessed.

Finally, the JNI Spec is an excellent source of documentation to learn more
about its design and API preconditions. These two sections are relevant to this
chapter: [Naming Rules](
https://docs.oracle.com/en/java/javase/11/docs/specs/jni/design.html#resolving-native-method-names)
and [JNIEnv](
https://docs.oracle.com/en/java/javase/11/docs/specs/jni/design.html#jni-interface-functions-and-pointers)
