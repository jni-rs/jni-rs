# Linking and Dividing

This section introduces writing JNI functions. After this chapter, you'll do a
short exercise using this material to divide two Java `int`s with Rust.

# Whats in NativeAPI?

`NativeAPI` is a class that lives in Java side of `jni_rs_java`. It loads the
`jnibookrs` shared library, and provides access to the native JNI functions. It
also contains the `verify_link` function, to help ensure that the environment
supports JNI and is setup properly. 

```java
package jni_rs_java;

// Note that you can have many classes that contain native methods, that there
// is no requirement that you name anything NativeAPI, or that you load libraries
// in static blocks.
class NativeAPI {

   private static final Throwable INIT_ERROR;

   // The static block will be executed the first time the NativeAPI
   // class is used.
   static {
       Throwable error = null;
       try {
           System.loadLibrary("jnibookrs");
       } catch (Throwable t) {
           error = t;
       }
       INIT_ERROR = error;
   }

   private NativeAPI() {
       // Not instantiable
   }

   static native int verify_link();
}
```

## Function Linking Rules
This section introduces naming Rust JNI functions, so that they may be used from
Java, as well as JNI parameters and return types.

### Naming Rust Functions for JNI
JNI encodes the package path, class name and function name to uniquely identify
the C function name that Java native methods should link to. Fortunately, you
don't have to learn the rules, since `javac` can be used to generate a C
function for you, which you can then copy for use with Rust. In this example,
we'll work with `NativeAPI` to generate a function name for `verify_link`.

To name the Rust JNI function, follow these steps.

1. Add a `native` function to a Java class. Remember that the package path,
   class name, and function name are all encoded into the C function name, so
   make sure those are as you want them.
2. Run `javac -h . NativeAPI.java` to produce C headers. (We assume that the
   class resides in `NativeAPI.java`, but it doesn't have to.)
3. Copy the C function name out of `NativeAPI.h`.

Upon completing these steps, you will see a file called
`jni_rs_book_NativeAPI.h` that contains the following (as well as
the function definitions that correspond to any native methods that you added):

```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class jni_rs_book_NativeAPI */

#ifndef _Included_jni_rs_book_NativeAPI
#define _Included_jni_rs_book_NativeAPI
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     jni_rs_book_NativeAPI
 * Method:    verify_link
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_jni_1rs_1book_NativeAPI_verify_1link
  (JNIEnv *, jclass);

#ifdef __cplusplus
}
#endif
#endif
```

`Java_jni_1rs_1book_NativeAPI_verify_1link` is the name of the Rust function
that corresponds to `verify_link`. `Java_` identifies that the function is for
Java, followed by the path, classname, and `verify_1link`. You may wonder what
the `_1` is for: it's the encoding mechanism that JNI uses to encode
underscores, as described in the [JNI spec on Resolving Native Method
Names](https://docs.oracle.com/en/java/javase/11/docs/specs/jni/design.html#resolving-native-method-names).

### Disabling Mangling and Specifying the ABI
There are a few annotations that must be applied to Rust functions, so that they
work with JNI. First, `#[no_mangle]` must be added to opt-out of name mangling
(a compiler technique that the Rust compiler leverages by default), so that the
carefully chosen JNI function name is unchanged. Secondly, `extern "system"`
must be used to specify the ABI (Application Binary Interface) to one that Java
expects. For further information, see
[extern](https://doc.rust-lang.org/std/keyword.extern.html) and
[abi](https://doc.rust-lang.org/beta/reference/items/external-blocks.html#abi).
Applying these two, we wind up with:

```rust,noplaypen
use jni::objects::JClass;
use jni::JNIEnv;

// #[no_mangle] - Disables name mangling, so that the compiler doesn't rename the function
// in the shared library.
//
// extern "system" - Specifies the ABI
#[no_mangle]
pub extern "system" fn Java_jni_1rs_1book_NativeAPI_verify_1link(
) {}
```


### Parameters
The first argument to every JNI function is `JNIEnv`, which is an object you can
use to call into the JVM. The second argument is a reference to `this`, which is
a `JClass` for static methods and `JObject` for instance methods. The next
arguments map 1:1 with parameters specified in the Java method's signature. For
example, if the signature was `void add(int a, int b)`, then the 3rd and 4th
arguments in the native function would be of type `jni::sys::jint`.

Since `verify_link` is static and takes no additional arguments, the function
should be written as:

```rust,noplaypen
use jni::objects::JClass;
use jni::JNIEnv;

// Although no arguments are used in this function, the first two arguments must
// always be in the native method's signature.
#[no_mangle]
pub extern "system" fn Java_jni_1rs_1book_NativeAPI_verify_1link(
    _env: JNIEnv,
    _class: JClass
) {}
```
# Summary

It's OK if the JNI naming conventions and parameters look unfamiliar. There are
a lot of steps involved, compared to normal Rust code. The key takeaways are:

1. `javac` can be used to generate function names
2. JNI functions need to be annotated with `#[no_mangle]`, and defined with
   `extern "system"`
3. `JNIEnv` and `JClass` are the first two args for static native functions. For
   instance native functions, they are `JNIEnv` and `JObject`.
4.  `JNIEnv` is the sole entrypoint through which Java objects may be accessed.

Finally, the JNI Spec is an excellent source of documentation, to learn more
about the design and API usage requirements. These two sections are relevant to
this chapter: [Naming Rules](
https://docs.oracle.com/en/java/javase/11/docs/specs/jni/design.html#resolving-native-method-names)
and [JNIEnv](
https://docs.oracle.com/en/java/javase/11/docs/specs/jni/design.html#jni-interface-functions-and-pointers)
