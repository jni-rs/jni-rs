//! # jbindgen
//!
//! A library for generating Rust bindings from Java class files.
//!
//! This library analyzes compiled Java `.class` files using the `cafebabe` parser
//! and generates Rust code that uses the `bind_java_type!` macro from the `jni` crate
//! to create type-safe bindings.
//!
//! ## Example
//!
//! ```rust,ignore
//! use jbindgen::Builder;
//! use std::path::Path;
//!
//! let bindings = Builder::new()
//!     .input_class(Path::new("path/to/MyClass.class"))
//!     .name_prefix("My")
//!     .generate()?;
//!
//! bindings.write_to_file("output.rs")?;
//! ```

mod android;
mod android_sdk;
mod cafebabe_parser;
mod error;
mod generator;
mod java_parser;
mod parser_types;

pub use android::HiddenApiFilter;
pub use android_sdk::AndroidSdk;
pub use error::{Error, Result};
pub use generator::{BindgenOptions, ModuleBinding, ModuleEvent, TypeMap};
pub use parser_types::{
    ArgInfo, ClassInfo, FieldInfo, InstanceOfInfo, MethodInfo, MethodSignature, TypeInfo,
};

use std::collections::HashMap;
use std::fs;
use std::io::{Read, Write};
use std::path::{Path, PathBuf};

/// Information about a single binding in a module
#[derive(Debug, Clone)]
pub struct BindingInfo {
    /// The Rust type name (e.g., "MyClass")
    pub rust_type_name: String,
    /// The Rust API type name (e.g., "MyClassAPI")
    pub rust_api_type_name: String,
    /// The generated binding code
    pub code: String,
    /// The Java type name (e.g., "MyClass" or "MyClass$Inner")
    pub java_type_name: String,
    /// The Java package (e.g., "com.example")
    pub package: String,
}

/// A hierarchical module containing bindings
#[derive(Debug, Clone)]
pub struct Module {
    /// The name of this module (e.g., "stuff" for com.example.stuff)
    pub name: String,
    /// Child modules
    children: HashMap<String, Module>,
    /// Bindings directly in this module with metadata
    pub bindings: Vec<BindingInfo>,
    /// Use statements for this module
    pub use_statements: Vec<String>,
}

impl Module {
    fn new(name: String) -> Self {
        Self {
            name,
            children: HashMap::new(),
            bindings: Vec::new(),
            use_statements: Vec::new(),
        }
    }

    /// Insert a binding into this module hierarchy
    fn insert(&mut self, module_path: &[String], binding: ModuleBinding) {
        if module_path.is_empty() {
            // This binding belongs in the current module
            self.bindings.push(BindingInfo {
                rust_type_name: binding.rust_type_name,
                rust_api_type_name: binding.rust_api_type_name,
                code: binding.binding_code,
                java_type_name: binding.java_type_name,
                package: binding.package,
            });

            // Merge use statements, avoiding duplicates
            for use_stmt in binding.use_statements {
                if !self.use_statements.contains(&use_stmt) {
                    self.use_statements.push(use_stmt);
                }
            }
        } else {
            // Navigate to the child module
            let child_name = &module_path[0];
            let child = self
                .children
                .entry(child_name.clone())
                .or_insert_with(|| Module::new(child_name.clone()));
            child.insert(&module_path[1..], binding);
        }
    }
}

/// Generated bindings that can be written to a file or converted to a string.
#[derive(Debug, Clone)]
pub struct Bindings {
    /// Root modules (top-level packages)
    root_modules: HashMap<String, Module>,
    /// Whether to generate jni_init methods
    generate_jni_init: bool,
    /// Input type mappings that were provided to the generator
    input_type_mappings: Vec<(String, String)>,
    /// Root path used for generated bindings
    root_path: String,
}

impl Bindings {
    /// Get the standard header comment for generated files
    fn generated_header() -> &'static str {
        "// This file was generated by jbindgen. Do not edit manually.\n\n"
    }

    /// Create a new Bindings instance from module bindings.
    fn new(module_bindings: Vec<ModuleBinding>, generate_jni_init: bool, input_type_mappings: Vec<(String, String)>, root_path: String) -> Self {
        let mut root_modules = HashMap::new();

        for binding in module_bindings {
            if binding.module_path.is_empty() {
                // Default package - insert into a special root
                let root = root_modules
                    .entry(String::new())
                    .or_insert_with(|| Module::new(String::new()));
                root.bindings.push(BindingInfo {
                    rust_type_name: binding.rust_type_name,
                    rust_api_type_name: binding.rust_api_type_name,
                    code: binding.binding_code,
                    java_type_name: binding.java_type_name,
                    package: binding.package,
                });
                for use_stmt in binding.use_statements {
                    if !root.use_statements.contains(&use_stmt) {
                        root.use_statements.push(use_stmt);
                    }
                }
            } else {
                // Regular package - insert into hierarchy
                let root_name = binding.module_path[0].clone();
                let rest_of_path = binding.module_path[1..].to_vec();
                let root = root_modules
                    .entry(root_name.clone())
                    .or_insert_with(|| Module::new(root_name));
                root.insert(&rest_of_path, binding);
            }
        }

        Self {
            root_modules,
            generate_jni_init,
            input_type_mappings,
            root_path,
        }
    }

    /// Write the bindings to a file.
    ///
    /// # Arguments
    ///
    /// * `path` - The file path to write to
    pub fn write_to_file<P: AsRef<Path>>(&self, path: P) -> Result<()> {
        let mut content = String::new();
        content.push_str(Self::generated_header());
        content.push_str(&self.to_string());

        let mut file = fs::File::create(path)?;
        file.write_all(content.as_bytes())?;
        Ok(())
    }

    /// Write the bindings to a directory structure with mod.rs files.
    ///
    /// This creates a Cargo-compatible module directory structure where each
    /// module level gets its own directory with a `mod.rs` file containing
    /// the module's contents and declarations for child modules.
    ///
    /// # Arguments
    ///
    /// * `base_path` - The base directory where the module structure will be created
    ///
    /// # Example
    ///
    /// For bindings with packages like `com.example.foo`, this will create:
    /// ```text
    /// base_path/
    ///   mod.rs              (declares "pub mod com;")
    ///   com/
    ///     mod.rs            (declares "pub mod example;" and contains com-level bindings)
    ///     example/
    ///       mod.rs          (declares "pub mod foo;" and contains example-level bindings)
    ///       foo/
    ///         mod.rs        (contains foo-level bindings)
    /// ```
    pub fn write_to_files<P: AsRef<Path>>(&self, base_path: P) -> Result<()> {
        let base_path = base_path.as_ref();

        // Create the base directory if it doesn't exist
        fs::create_dir_all(base_path)?;

        // Collect all modules that need to be written
        let mut module_paths: Vec<(Vec<String>, &Module)> = Vec::new();

        self.collect_modules(&mut module_paths);

        // Write each module
        for (path_segments, module) in module_paths {
            self.write_module(base_path, &path_segments, module)?;
        }

        // Write the root mod.rs if there are root modules
        if !self.root_modules.is_empty() {
            let root_mod_path = base_path.join("mod.rs");
            let mut root_content = String::new();

            // Add generated header
            root_content.push_str(Self::generated_header());

            // Add module declarations for all root modules
            let mut root_names: Vec<_> = self.root_modules.keys().collect();
            root_names.sort();

            for root_name in root_names {
                if !root_name.is_empty() {
                    root_content.push_str(&format!("pub mod {};\n", root_name));
                }
            }

            // If there's a default package (empty string key), add its bindings directly
            if let Some(default_module) = self.root_modules.get("") {
                if !default_module.bindings.is_empty() {
                    root_content.push('\n');
                    for use_stmt in &default_module.use_statements {
                        root_content.push_str(use_stmt);
                        root_content.push('\n');
                    }
                    if !default_module.use_statements.is_empty() {
                        root_content.push('\n');
                    }
                    for binding in &default_module.bindings {
                        root_content.push_str(&binding.code);
                        root_content.push('\n');
                    }
                }
            }

            // Add root-level jni_init if enabled
            if self.generate_jni_init {
                root_content.push('\n');
                root_content.push_str("/// Initialize all Java bindings.\n");
                root_content.push_str("///\n");
                root_content.push_str(
                    "/// This loads and caches JClass references and method/field IDs for all\n",
                );
                root_content.push_str("/// bindings in all modules.\n");
                root_content.push_str("///\n");
                root_content.push_str("/// # Arguments\n");
                root_content.push_str("///\n");
                root_content.push_str("/// * `env` - The JNI environment\n");
                root_content
                    .push_str("/// * `loader` - The LoaderContext to use for loading classes\n");
                root_content.push_str("pub fn jni_init(env: &::jni::Env, loader: &::jni::refs::LoaderContext) -> ::jni::errors::Result<()> {\n");

                // Initialize default package bindings if any
                if let Some(default_module) = self.root_modules.get("") {
                    for binding in &default_module.bindings {
                        root_content.push_str(&format!(
                            "    let _ = {}::get(env, loader)?;\n",
                            binding.rust_api_type_name
                        ));
                    }
                }

                // Initialize all root modules
                let mut root_names: Vec<_> = self
                    .root_modules
                    .keys()
                    .filter(|&name| !name.is_empty())
                    .collect();
                root_names.sort();

                for root_name in root_names {
                    root_content.push_str(&format!("    {}::jni_init(env, loader)?;\n", root_name));
                }

                root_content.push_str("    Ok(())\n");
                root_content.push_str("}\n");
            }

            fs::write(root_mod_path, root_content)?;
        }

        Ok(())
    }

    /// Helper to collect all modules into a flat list with their paths
    fn collect_modules<'a>(&'a self, modules: &mut Vec<(Vec<String>, &'a Module)>) {
        for (root_name, root_module) in &self.root_modules {
            if !root_name.is_empty() {
                let path = vec![root_name.clone()];
                modules.push((path.clone(), root_module));
                Self::collect_children_modules(&path, root_module, modules);
            }
        }
    }

    fn collect_children_modules<'a>(
        parent_path: &[String],
        module: &'a Module,
        modules: &mut Vec<(Vec<String>, &'a Module)>,
    ) {
        for (child_name, child_module) in &module.children {
            let mut path = parent_path.to_vec();
            path.push(child_name.clone());
            modules.push((path.clone(), child_module));
            Self::collect_children_modules(&path, child_module, modules);
        }
    }

    /// Generate jni_init function code for a module
    fn generate_jni_init(module: &Module) -> String {
        let mut output = String::new();

        output.push_str("/// Initialize all Java bindings in this module.\n");
        output.push_str("///\n");
        output
            .push_str("/// This loads and caches JClass references and method/field IDs for all\n");
        output.push_str("/// bindings in this module and its child modules.\n");
        output.push_str("///\n");
        output.push_str("/// # Arguments\n");
        output.push_str("///\n");
        output.push_str("/// * `env` - The JNI environment\n");
        output.push_str("/// * `loader` - The LoaderContext to use for loading classes\n");
        output.push_str("pub fn jni_init(env: &::jni::Env, loader: &::jni::refs::LoaderContext) -> ::jni::errors::Result<()> {\n");

        // Load all bindings in this module
        for binding in &module.bindings {
            output.push_str(&format!(
                "    let _ = {}::get(env, loader)?;\n",
                binding.rust_api_type_name
            ));
        }

        // Initialize all child modules
        let mut child_names: Vec<_> = module.children.keys().collect();
        child_names.sort();

        for child_name in child_names {
            output.push_str(&format!("    {}::jni_init(env, loader)?;\n", child_name));
        }

        output.push_str("    Ok(())\n");
        output.push_str("}\n");

        output
    }

    /// Helper to write a single module to its directory
    fn write_module(
        &self,
        base_path: &Path,
        path_segments: &[String],
        module: &Module,
    ) -> Result<()> {
        // Build the directory path
        let mut dir_path = base_path.to_path_buf();
        for segment in path_segments {
            dir_path.push(segment);
        }

        // Create the directory
        fs::create_dir_all(&dir_path)?;

        // Write mod.rs
        let mod_path = dir_path.join("mod.rs");
        let mut content = String::new();

        // Add generated header
        content.push_str(Self::generated_header());

        // Add child module declarations
        if !module.children.is_empty() {
            let mut child_names: Vec<_> = module.children.keys().collect();
            child_names.sort();

            for child_name in child_names {
                content.push_str(&format!("pub mod {};\n", child_name));
            }
            content.push('\n');
        }

        // Add use statements
        if !module.use_statements.is_empty() {
            for use_stmt in &module.use_statements {
                content.push_str(use_stmt);
                content.push('\n');
            }
            content.push('\n');
        }

        // Add bindings
        for binding in &module.bindings {
            content.push_str(&binding.code);
            content.push('\n');
        }

        // Add jni_init function if enabled and module has any bindings or children
        if self.generate_jni_init && (!module.bindings.is_empty() || !module.children.is_empty()) {
            content.push('\n');
            content.push_str(&Self::generate_jni_init(module));
        }

        fs::write(mod_path, content)?;

        Ok(())
    }

    /// Get the bindings as a string.
    pub fn to_string(&self) -> String {
        let mut output = String::new();

        // Add generated header
        output.push_str(Self::generated_header());

        self.walk(&mut |module, event| {
            match event {
                ModuleEvent::BeginModule => {
                    if !module.name.is_empty() {
                        output.push_str(&format!("pub mod {} {{\n", module.name));
                    }

                    // Add use statements
                    if !module.use_statements.is_empty() {
                        for use_stmt in &module.use_statements {
                            if !module.name.is_empty() {
                                output.push_str(&format!("    {}\n", use_stmt));
                            } else {
                                output.push_str(use_stmt);
                                output.push('\n');
                            }
                        }
                        output.push('\n');
                    }

                    // Add bindings
                    for binding in &module.bindings {
                        // Indent each line of the binding
                        if !module.name.is_empty() {
                            for line in binding.code.lines() {
                                output.push_str("    ");
                                output.push_str(line);
                                output.push('\n');
                            }
                        } else {
                            output.push_str(&binding.code);
                        }
                        output.push('\n');
                    }
                }
                ModuleEvent::EndModule => {
                    // Add jni_init function if enabled and module has any bindings or children
                    // Skip for root/default package modules (empty name) as they're handled separately
                    if self.generate_jni_init
                        && !module.name.is_empty()
                        && (!module.bindings.is_empty() || !module.children.is_empty())
                    {
                        // Indent the jni_init function for non-root modules
                        output.push('\n');
                        for line in Self::generate_jni_init(module).lines() {
                            output.push_str("    ");
                            output.push_str(line);
                            output.push('\n');
                        }
                    }

                    if !module.name.is_empty() {
                        output.push_str("}\n");
                    }
                }
            }
        });

        // Generate root-level jni_init after all modules
        if self.generate_jni_init {
            // Collect all root module names (excluding default package)
            let mut root_names: Vec<_> = self
                .root_modules
                .keys()
                .filter(|&name| !name.is_empty())
                .collect();
            root_names.sort();

            // Check if there are any default package bindings
            let default_bindings = self
                .root_modules
                .get("")
                .map(|m| &m.bindings)
                .filter(|b| !b.is_empty());

            // Generate root jni_init if there are any modules or default package bindings
            if !root_names.is_empty() || default_bindings.is_some() {
                output.push('\n');
                output.push_str("/// Initialize all Java bindings.\n");
                output.push_str("///\n");
                output.push_str(
                    "/// This loads and caches JClass references and method/field IDs for all\n",
                );
                output.push_str("/// bindings in all modules.\n");
                output.push_str("///\n");
                output.push_str("/// # Arguments\n");
                output.push_str("///\n");
                output.push_str("/// * `env` - The JNI environment\n");
                output.push_str("/// * `loader` - The LoaderContext to use for loading classes\n");
                output.push_str(
                    "pub fn jni_init(env: &jni::Env, loader: &jni::refs::LoaderContext) -> jni::errors::Result<()> {\n",
                );

                // Initialize default package bindings if any
                if let Some(bindings) = default_bindings {
                    for binding in bindings {
                        output.push_str(&format!(
                            "    let _ = {}::get(env, loader)?;\n",
                            binding.rust_api_type_name
                        ));
                    }
                }

                // Initialize all root modules
                for root_name in root_names {
                    output.push_str(&format!("    {}::jni_init(env, loader)?;\n", root_name));
                }

                output.push_str("    Ok(())\n");
                output.push_str("}\n");
            }
        }

        output
    }

    /// Walk the module tree depth-first, calling a closure for each module.
    ///
    /// The closure is called twice per module: once with `BeginModule` before processing
    /// the module's contents, and once with `EndModule` after all children have been processed.
    ///
    /// # Arguments
    ///
    /// * `callback` - A closure that receives a reference to the module and the event type
    pub fn walk<F>(&self, callback: &mut F)
    where
        F: FnMut(&Module, ModuleEvent),
    {
        // Sort root modules by name for deterministic output
        let mut root_names: Vec<_> = self.root_modules.keys().collect();
        root_names.sort();

        for root_name in root_names {
            if let Some(module) = self.root_modules.get(root_name) {
                Self::walk_module(module, callback);
            }
        }
    }

    fn walk_module<F>(module: &Module, callback: &mut F)
    where
        F: FnMut(&Module, ModuleEvent),
    {
        callback(module, ModuleEvent::BeginModule);

        // Sort child modules by name for deterministic output
        let mut child_names: Vec<_> = module.children.keys().collect();
        child_names.sort();

        for child_name in child_names {
            if let Some(child) = module.children.get(child_name) {
                Self::walk_module(child, callback);
            }
        }

        callback(module, ModuleEvent::EndModule);
    }

    /// Get the number of generated bindings.
    pub fn len(&self) -> usize {
        self.count_bindings()
    }

    fn count_bindings(&self) -> usize {
        let mut count = 0;
        for module in self.root_modules.values() {
            count += Self::count_module_bindings(module);
        }
        count
    }

    fn count_module_bindings(module: &Module) -> usize {
        let mut count = module.bindings.len();
        for child in module.children.values() {
            count += Self::count_module_bindings(child);
        }
        count
    }

    /// Check if there are no bindings.
    pub fn is_empty(&self) -> bool {
        self.root_modules.is_empty()
    }

    /// Get a complete TypeMap including input mappings and generated bindings.
    ///
    /// This creates a TypeMap that includes all the type mappings that were
    /// provided as input to the generator, plus mappings for all generated bindings.
    ///
    /// # Arguments
    ///
    /// * `pub_root_path` - Optional public root path to use instead of the internal root path.
    ///   For example, if bindings were generated with root_path "crate" but the crate's public
    ///   API uses "my_crate", pass Some("my_crate") to map internal paths to public paths.
    ///
    /// # Returns
    ///
    /// A TypeMap containing all input mappings plus mappings for generated bindings.
    pub fn type_map(&self, pub_root_path: Option<&str>) -> TypeMap {
        let mut type_map = TypeMap::new();

        // Add input mappings
        for (rust_type, java_type) in &self.input_type_mappings {
            type_map.insert(java_type.clone(), rust_type.clone());
        }

        // Add generated bindings
        for (root_name, root_module) in &self.root_modules {
            let mut path = Vec::new();
            if !root_name.is_empty() {
                path.push(root_name.clone());
            }
            self.collect_type_mappings(root_module, &path, &mut type_map, pub_root_path);
        }

        type_map
    }

    /// Helper to recursively collect type mappings from modules
    fn collect_type_mappings(
        &self,
        module: &Module,
        current_path: &[String],
        type_map: &mut TypeMap,
        pub_root_path: Option<&str>,
    ) {
        // Add bindings from this module
        for binding in &module.bindings {
            // Build rust path: root::path::to::module::TypeName
            let root_path = pub_root_path.unwrap_or(&self.root_path);
            let mut rust_path = root_path.to_string();
            for segment in current_path {
                rust_path.push_str("::");
                rust_path.push_str(segment);
            }
            rust_path.push_str("::");
            rust_path.push_str(&binding.rust_type_name);

            // Build java type: package.TypeName
            let java_type = if binding.package.is_empty() {
                format!(".{}", binding.java_type_name)
            } else {
                format!("{}.{}", binding.package, binding.java_type_name)
            };

            type_map.insert(java_type, rust_path);
        }

        // Recurse into children
        for (child_name, child_module) in &module.children {
            let mut child_path = current_path.to_vec();
            child_path.push(child_name.clone());
            self.collect_type_mappings(child_module, &child_path, type_map, pub_root_path);
        }
    }

    /// Write the type map to a file.
    ///
    /// Writes one mapping per line in the format: `path::to::RustType => "com.example.JavaType"`
    ///
    /// # Arguments
    ///
    /// * `path` - The file path to write to
    pub fn write_type_map<P: AsRef<Path>>(&self, path: P) -> Result<()> {
        self.write_type_map_internal(path, None)
    }

    /// Write the type map to a file using a public root path.
    ///
    /// Writes one mapping per line in the format: `path::to::RustType => "com.example.JavaType"`
    ///
    /// # Arguments
    ///
    /// * `path` - The file path to write to
    /// * `pub_root_path` - Public root path to use instead of the internal root path
    pub fn write_pub_type_map<P: AsRef<Path>>(&self, path: P, pub_root_path: &str) -> Result<()> {
        self.write_type_map_internal(path, Some(pub_root_path))
    }

    fn write_type_map_internal<P: AsRef<Path>>(&self, path: P, pub_root_path: Option<&str>) -> Result<()> {
        let type_map = self.type_map(pub_root_path);
        let mut file = fs::File::create(path)?;

        // Collect and sort mappings for deterministic output
        let mut mappings: Vec<_> = type_map.iter().collect();
        mappings.sort_by_key(|(java, _)| java.as_str());

        for (java_type, rust_type) in mappings {
            writeln!(file, "{} => \"{}\"", rust_type, java_type)?;
        }

        Ok(())
    }
}

/// Input source for generating bindings.
#[derive(Debug, Clone)]
enum InputSource {
    /// A single .class file
    ClassFile(PathBuf),
    /// Raw bytes of a .class file
    ClassBytes(Vec<u8>),
    /// A JAR file with optional class patterns for filtering
    JarFile {
        path: PathBuf,
        patterns: Vec<String>,
    },
    /// Java source files
    Sources {
        source_paths: Vec<PathBuf>,
        classpath: Vec<PathBuf>,
        patterns: Vec<String>,
    },
    /// Android SDK
    AndroidSdk {
        api_level: u32,
        patterns: Vec<String>,
        hiddenapi_flags_path: Option<PathBuf>,
    },
}

/// Builder for configuring and generating Java bindings.
///
/// This follows the builder pattern similar to bindgen for C/C++.
///
/// # Example
///
/// ```rust,ignore
/// use jbindgen::Builder;
///
/// let bindings = Builder::new()
///     .input_class("MyClass.class")
///     .name_prefix("Java")
///     .private_type(false)
///     .generate()?;
///
/// bindings.write_to_file("bindings.rs")?;
/// ```
#[derive(Debug, Clone)]
pub struct Builder {
    input: Option<InputSource>,
    public_type: bool,
    rust_type_name: Option<String>,
    name_prefix: Option<String>,
    type_map: Vec<(String, String)>,
    generate_native_interfaces: bool,
    generate_jni_init: bool,
    hidden_api_filter: android::HiddenApiFilter,
    root_path: String,
    skip_signatures: Vec<String>,
    name_overrides: HashMap<String, String>,
}

impl Default for Builder {
    fn default() -> Self {
        Self::new()
    }
}

impl Builder {
    /// Create a new builder with default settings.
    ///
    /// Note: You should call `.root_path()` to set the module path where bindings will be generated.
    pub fn new() -> Self {
        Self {
            input: None,
            public_type: true,
            rust_type_name: None,
            name_prefix: None,
            type_map: Vec::new(),
            generate_native_interfaces: true,
            generate_jni_init: true,
            hidden_api_filter: android::HiddenApiFilter::default(),
            root_path: String::from("crate"),
            skip_signatures: Vec::new(),
            name_overrides: HashMap::new(),
        }
    }

    /// Set the input to a .class file.
    pub fn input_class<P: AsRef<Path>>(mut self, path: P) -> Self {
        self.input = Some(InputSource::ClassFile(path.as_ref().to_path_buf()));
        self
    }

    /// Set the input to raw .class file bytes.
    pub fn input_class_bytes(mut self, bytes: Vec<u8>) -> Self {
        self.input = Some(InputSource::ClassBytes(bytes));
        self
    }

    /// Set the input to a JAR file.
    pub fn input_jar<P: AsRef<Path>>(mut self, path: P) -> Self {
        self.input = Some(InputSource::JarFile {
            path: path.as_ref().to_path_buf(),
            patterns: Vec::new(),
        });
        self
    }

    /// Set the input to Java source files.
    ///
    /// # Arguments
    ///
    /// * `source_paths` - Paths to Java source files or directories
    /// * `classpath` - Classpath entries needed for compilation
    /// * `patterns` - Patterns to match classes (e.g., ["android.app.*", "android.os.Build"])
    pub fn input_sources(
        mut self,
        source_paths: Vec<PathBuf>,
        classpath: Vec<PathBuf>,
        patterns: Vec<String>,
    ) -> Self {
        self.input = Some(InputSource::Sources {
            source_paths,
            classpath,
            patterns,
        });
        self
    }

    /// Set the input to Android SDK APIs.
    ///
    /// # Arguments
    ///
    /// * `api_level` - Android API level (e.g., 33, 35)
    /// * `patterns` - Patterns to match SDK APIs (e.g., ["android.app.*", "android.os.Build"])
    ///
    /// Use `.patterns()` to add additional patterns after construction.
    /// Use `.hiddenapi_flags()` to set the path to hiddenapi-flags.csv for filtering.
    pub fn input_android_sdk(mut self, api_level: u32, patterns: Vec<String>) -> Self {
        self.input = Some(InputSource::AndroidSdk {
            api_level,
            patterns,
            hiddenapi_flags_path: None,
        });
        self
    }

    /// Set the path to hiddenapi-flags.csv for filtering Android SDK APIs.
    ///
    /// Only applies to Android SDK input. Filters out non-public/hidden APIs.
    /// By default, only APIs marked as "public-api" or "sdk" are included.
    /// Use `.allow_unsupported()` and `.max_target()` to include additional APIs.
    ///
    /// # Arguments
    ///
    /// * `path` - Path to hiddenapi-flags.csv file
    pub fn hiddenapi_flags<P: AsRef<Path>>(mut self, path: P) -> Self {
        if let Some(InputSource::AndroidSdk {
            hiddenapi_flags_path,
            ..
        }) = &mut self.input
        {
            *hiddenapi_flags_path = Some(path.as_ref().to_path_buf());
        }
        self
    }

    /// Allow "unsupported" APIs when filtering with hiddenapi-flags.csv.
    ///
    /// Only applies to Android SDK input when a hiddenapi-flags.csv file is provided.
    /// By default, only "public-api" and "sdk" APIs are included.
    ///
    /// # Arguments
    ///
    /// * `allow` - Whether to allow unsupported APIs (default: false)
    pub fn allow_unsupported(mut self, allow: bool) -> Self {
        self.hidden_api_filter.allow_unsupported = allow;
        self
    }

    /// Set maximum target level for conditional API support when filtering with hiddenapi-flags.csv.
    ///
    /// Only applies to Android SDK input when a hiddenapi-flags.csv file is provided.
    /// APIs with `max-target-<level>` flags are included if their level is >= the specified level.
    ///
    /// # Arguments
    ///
    /// * `target` - Target level code (e.g., "o" for Oreo, "p" for Pie, "q" for Android 10)
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// builder.max_target("o")  // Include APIs with max-target-o and higher
    /// ```
    pub fn max_target<S: Into<String>>(mut self, target: S) -> Self {
        self.hidden_api_filter.max_target = Some(target.into());
        self
    }

    /// Make the generated type public (default: true).
    pub fn public_type(mut self, public: bool) -> Self {
        self.public_type = public;
        self
    }

    /// Make the generated type private.
    pub fn private_type(mut self, private: bool) -> Self {
        self.public_type = !private;
        self
    }

    /// Override the generated Rust type name.
    ///
    /// Only applicable for single class files, ignored for JAR/multiple sources.
    pub fn rust_type_name<S: Into<String>>(mut self, name: S) -> Self {
        self.rust_type_name = Some(name.into());
        self
    }

    /// Add a prefix to all generated Rust type names.
    pub fn name_prefix<S: Into<String>>(mut self, prefix: S) -> Self {
        self.name_prefix = Some(prefix.into());
        self
    }

    /// Set class patterns for filtering which classes to generate bindings for.
    ///
    /// Only applies to JAR files, Android SDK, and source files.
    /// Patterns can use wildcards like "android.app.*" or exact matches like "android.os.Build".
    ///
    /// For JAR files, patterns match against the class path (e.g., "com/example/MyClass.class").
    pub fn patterns<I, S>(mut self, patterns: I) -> Self
    where
        I: IntoIterator<Item = S>,
        S: Into<String>,
    {
        let patterns_vec: Vec<String> = patterns.into_iter().map(|s| s.into()).collect();

        match &mut self.input {
            Some(InputSource::JarFile { patterns, .. }) => {
                *patterns = patterns_vec;
            }
            Some(InputSource::Sources { patterns, .. }) => {
                *patterns = patterns_vec;
            }
            Some(InputSource::AndroidSdk { patterns, .. }) => {
                *patterns = patterns_vec;
            }
            _ => {
                // Ignore for ClassFile and ClassBytes inputs
            }
        }
        self
    }

    /// Add a type mapping from Rust type to Java type.
    ///
    /// # Arguments
    ///
    /// * `rust_type` - The Rust type name to use
    /// * `java_type` - The fully qualified Java type name
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// builder.type_mapping("MyBundle", "android.os.Bundle")
    /// ```
    pub fn type_mapping<S1: Into<String>, S2: Into<String>>(
        mut self,
        rust_type: S1,
        java_type: S2,
    ) -> Self {
        self.type_map.push((rust_type.into(), java_type.into()));
        self
    }

    /// Add multiple type mappings.
    pub fn type_mappings(mut self, mappings: Vec<(String, String)>) -> Self {
        self.type_map.extend(mappings);
        self
    }

    /// Control whether to generate native method interfaces (default: true).
    ///
    /// When enabled, native methods are placed in the `native_methods` block and
    /// require trait implementation. When disabled, native methods are placed in
    /// the `methods` block and can be called but not implemented.
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// builder.generate_native_interfaces(false)
    /// ```
    pub fn generate_native_interfaces(mut self, generate: bool) -> Self {
        self.generate_native_interfaces = generate;
        self
    }

    /// Control whether to generate `jni_init` methods for modules (default: true).
    ///
    /// When enabled, each module will have a `jni_init(loader: &LoaderContext) -> Result<()>`
    /// function that calls `RustTypeAPI::get(loader)?` for each binding in the module,
    /// as well as `child_module::jni_init(loader)?` for each child module.
    ///
    /// These functions allow explicit control over when to load and cache classes,
    /// method IDs, and field IDs, which can be useful when working with specific
    /// ClassLoaders or for runtime testing of binding correctness.
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// builder.generate_jni_init(false)  // Disable jni_init generation
    /// ```
    pub fn generate_jni_init(mut self, generate: bool) -> Self {
        self.generate_jni_init = generate;
        self
    }

    /// Skip methods or fields matching the given DEX signature.
    ///
    /// The signature should be in DEX format as found in hiddenapi-flags.csv:
    /// - Method: `Lcom/example/Class;->methodName(Ljava/lang/String;)V`
    /// - Field: `Lcom/example/Class;->fieldName:Ljava/lang/String;`
    ///
    /// This is useful for skipping deprecated or problematic APIs.
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// builder.skip_signature("Landroid/content/Intent;->toURI()Ljava/lang/String;")
    /// ```
    pub fn skip_signature<S: Into<String>>(mut self, signature: S) -> Self {
        self.skip_signatures.push(signature.into());
        self
    }

    /// Override the Rust name for a method or field matching the given DEX signature.
    ///
    /// The signature should be in DEX format as found in hiddenapi-flags.csv:
    /// - Method: `Lcom/example/Class;->methodName(Ljava/lang/String;)V`
    /// - Field: `Lcom/example/Class;->fieldName:Ljava/lang/String;`
    ///
    /// This is useful for resolving name conflicts (e.g., deprecated `toURI` vs `toUri`).
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// builder.name_override(
    ///     "Landroid/content/Intent;->toURI()Ljava/lang/String;",
    ///     "to_uri_deprecated"
    /// )
    /// ```
    pub fn name_override<S1: Into<String>, S2: Into<String>>(
        mut self,
        signature: S1,
        name: S2,
    ) -> Self {
        self.name_overrides.insert(signature.into(), name.into());
        self
    }

    /// Set the root module path for generated bindings.
    ///
    /// This determines the fully-qualified Rust module path that will be used in type_map
    /// entries. This is essential for cross-package type references to work correctly.
    ///
    /// # Arguments
    ///
    /// * `path` - The root module path (e.g., "crate::bindings::sdk", "crate::java")
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// builder.root_path("crate::bindings::sdk")
    /// ```
    pub fn root_path<S: Into<String>>(mut self, path: S) -> Self {
        self.root_path = path.into();
        self
    }

    /// Generate the bindings.
    ///
    /// # Returns
    ///
    /// A `Bindings` object that can be written to a file or converted to a string.
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - No input source was specified
    /// - The input file doesn't exist or can't be read
    /// - The class file is malformed
    /// - Binding generation fails
    pub fn generate(self) -> Result<Bindings> {
        let input = self
            .input
            .ok_or_else(|| Error::CodeGen("No input source specified".to_string()))?;

        let options = BindgenOptions {
            public_type: self.public_type,
            rust_type_name: self.rust_type_name.clone(),
            name_prefix: self.name_prefix.clone(),
            generate_native_interfaces: self.generate_native_interfaces,
            generate_jni_init: self.generate_jni_init,
            root_path: self.root_path.clone(),
            skip_signatures: self.skip_signatures.clone(),
            name_overrides: self.name_overrides.clone(),
        };

        let root_path = self.root_path.clone();
        let type_map = self.type_map.clone();
        let generate_jni_init = self.generate_jni_init;

        match input {
            InputSource::ClassFile(path) => {
                let binding = generate_bindings_with_type_map(&path, &options, type_map.clone())?;
                Ok(Bindings::new(vec![binding], generate_jni_init, type_map, root_path))
            }
            InputSource::ClassBytes(bytes) => {
                let binding = generate_bindings_from_bytes(&bytes, &options, type_map.clone())?;
                Ok(Bindings::new(vec![binding], generate_jni_init, type_map, root_path))
            }
            InputSource::JarFile { path, patterns } => {
                let bindings =
                    generate_bindings_from_jar(&path, &patterns, &options, type_map.clone())?;
                Ok(Bindings::new(bindings, generate_jni_init, type_map, root_path))
            }
            InputSource::Sources {
                source_paths,
                classpath,
                patterns,
            } => {
                let bindings = generate_bindings_from_sources(
                    &source_paths,
                    &classpath,
                    &patterns,
                    &options,
                    type_map.clone(),
                )?;
                Ok(Bindings::new(bindings, generate_jni_init, type_map, root_path))
            }
            InputSource::AndroidSdk {
                api_level,
                patterns,
                hiddenapi_flags_path,
            } => {
                // For Android SDK bindings, native methods are implemented by the platform,
                // so we disable native method interface generation
                let mut android_options = options.clone();
                android_options.generate_native_interfaces = false;

                let bindings = android::generate_android_bindings(
                    api_level,
                    &patterns,
                    hiddenapi_flags_path.as_deref(),
                    &self.hidden_api_filter,
                    &android_options,
                    type_map.clone(),
                )?;
                Ok(Bindings::new(bindings, generate_jni_init, type_map, root_path))
            }
        }
    }
}

// Internal helper functions used by Builder

/// Check if a class name matches any of the given patterns.
/// Patterns can use wildcards like "android.app.*" or exact matches.
/// For JAR files, patterns match against paths like "com/example/MyClass.class"
fn matches_any_pattern(name: &str, patterns: &[String]) -> bool {
    // Convert class file path to Java package format for matching
    let normalized_name = name.trim_end_matches(".class").replace('/', ".");

    for pattern in patterns {
        // Convert pattern slashes to dots for consistent matching
        let normalized_pattern = pattern.replace('/', ".");

        if normalized_pattern.ends_with(".*") {
            // Wildcard pattern - match package prefix
            let prefix = normalized_pattern.trim_end_matches(".*");
            if normalized_name == prefix || normalized_name.starts_with(&format!("{}.", prefix)) {
                return true;
            }
        } else if normalized_pattern == "*" {
            // Match all
            return true;
        } else if normalized_name == normalized_pattern {
            // Exact match
            return true;
        } else if normalized_pattern.contains('$') {
            // Specific inner class pattern - no further matching
            continue;
        } else {
            // Outer class pattern - check if this is an inner class of the matched pattern
            // e.g., pattern "android.os.Build" should match "android.os.Build$Partition"
            if normalized_name.starts_with(&format!("{}$", normalized_pattern)) {
                return true;
            }
            // Also try matching against the raw path for backwards compatibility
            if name.contains(&normalized_pattern.replace('.', "/")) {
                return true;
            }
        }
    }
    false
}

fn generate_bindings_with_type_map(
    class_file_path: &Path,
    options: &BindgenOptions,
    extra_type_map: Vec<(String, String)>,
) -> Result<ModuleBinding> {
    let bytes = fs::read(class_file_path)?;
    generate_bindings_from_bytes(&bytes, options, extra_type_map)
}

fn generate_bindings_from_bytes(
    bytes: &[u8],
    options: &BindgenOptions,
    extra_type_map: Vec<(String, String)>,
) -> Result<ModuleBinding> {
    let class = cafebabe::parse_class(bytes)?;
    let class_info = cafebabe_parser::parse_class(&class)?;

    let mut type_map = generator::TypeMap::from_classes(std::iter::once(&class_info), options);
    type_map.merge(extra_type_map);

    generator::generate_with_type_map(&class_info, options, &type_map)
}

fn generate_bindings_from_jar(
    jar_path: &Path,
    patterns: &[String],
    options: &BindgenOptions,
    extra_type_map: Vec<(String, String)>,
) -> Result<Vec<ModuleBinding>> {
    let file = fs::File::open(jar_path)?;
    let mut archive = zip::ZipArchive::new(file)?;

    let mut classes = Vec::new();

    for i in 0..archive.len() {
        let mut file = archive.by_index(i)?;
        let name = file.name().to_string();

        if !name.ends_with(".class") {
            continue;
        }

        // Filter by patterns if provided
        if !patterns.is_empty() && !matches_any_pattern(&name, patterns) {
            continue;
        }

        let mut bytes = Vec::new();
        file.read_to_end(&mut bytes)?;

        let class = cafebabe::parse_class(&bytes)
            .map_err(|e| Error::CodeGen(format!("Failed to parse cafebabe for {}: {}", name, e)))?;
        let class_info = cafebabe_parser::parse_class(&class)
            .map_err(|e| Error::CodeGen(format!("Failed to parse {}: {}", name, e)))?;

        classes.push((name.clone(), class_info));
    }

    let mut type_map = generator::TypeMap::from_classes(classes.iter().map(|(_, c)| c), options);
    type_map.merge(extra_type_map);

    let mut results = Vec::new();
    for (name, class_info) in classes {
        let binding =
            generator::generate_with_type_map(&class_info, options, &type_map).map_err(|e| {
                Error::CodeGen(format!("Failed to generate bindings for {}: {}", name, e))
            })?;
        results.push(binding);
    }

    Ok(results)
}

fn generate_bindings_from_sources(
    source_paths: &[PathBuf],
    class_path_entries: &[PathBuf],
    patterns: &[String],
    options: &BindgenOptions,
    extra_type_map: Vec<(String, String)>,
) -> Result<Vec<ModuleBinding>> {
    // Parse sources using Java parser, passing all patterns
    let pattern_str = if patterns.is_empty() {
        "*".to_string()
    } else {
        patterns.join(",")
    };
    let classes = java_parser::parse_java_sources(source_paths, class_path_entries, &pattern_str)?;

    let mut type_map = generator::TypeMap::from_classes(classes.iter(), options);
    type_map.merge(extra_type_map);

    let mut results = Vec::new();

    for class_info in classes {
        let class_name = class_info.class_name.clone();

        let binding =
            generator::generate_with_type_map(&class_info, options, &type_map).map_err(|e| {
                Error::CodeGen(format!(
                    "Failed to generate bindings for {}: {}",
                    class_name, e
                ))
            })?;
        results.push(binding);
    }

    Ok(results)
}
