#![cfg(feature = "invocation")]
//! Tests that it's possible to register native methods that are used within
//! static initializers in Java classes.
//!
//! For this to work the `<Type>API::get` method that's generated by the
//! `bind_java_type!` macro must avoid triggering the static initializer before
//! registering the native methods.
//!
mod bind_native_methods_utils;
mod util;

use jni::objects::JClass;
use jni::sys::jint;
use jni::{Env, bind_java_type};
use rusty_fork::rusty_fork_test;

bind_java_type! {
    rust_type = TestNativeStaticInit,
    java_type = "com.example.TestNativeStaticInit",
    methods {
        static fn get_static_value() -> jint,
    },
    native_methods {
        static fn native_initialize_static(jint) -> jint,
    }
}
impl TestNativeStaticInitNativeInterface for TestNativeStaticInitAPI {
    type Error = jni::errors::Error;

    fn native_initialize_static<'local>(
        _env: &mut Env<'local>,
        _class: JClass<'local>,
        value: jint,
    ) -> Result<jint, Self::Error> {
        Ok(value + 27)
    }
}

native_method_test! {
    test_name: test_native_method_in_static_initializer,
    java_class: "com/example/TestNativeStaticInit.java",
    api: TestNativeStaticInitAPI,
    test_body: |env| {
        // The static initializer will have to run before we can call get_static_value

        // Verify that the static value was set correctly by the native method
        let static_value = TestNativeStaticInit::get_static_value(env)?;
        assert_eq!(static_value, 42, "Static value should 5 + 10 + 27 = 42");

        // redundantly re-get the API to ensure the static init does not somehow run again
        let _ = TestNativeStaticInitAPI::get(env, &Default::default())?;

        let static_value = TestNativeStaticInit::get_static_value(env)?;
        assert_eq!(static_value, 42, "Static value should still be 42");

        Ok(())
    }
}
